# FILE ORGANIZER v6.2 - FEATURE SPECIFICATION

**Version:** 6.2
**Feature:** Recursive Organization Mode
**Status:** üìã PLANNING
**Author:** The Architect
**Date:** November 1, 2025

---

## üéØ FEATURE OVERVIEW

**Feature Name:** Recursive Organization Mode

**Problem Statement:**
Users have files already organized into top-level folders (A/, B/, C/, etc.) but need further sub-organization WITHIN those folders. Current version blocks organizing when source == target to prevent recursion issues.

**Solution:**
Add optional "Recursive Organization Mode" that safely organizes files within their current folders, with depth limiting and loop detection.

---

## üìã USER REQUIREMENTS

### Requirement 1: Organize Within Same Folder
**Description:** Allow organizing files where source == target
**Example:**
```
Source: C:\Photos\A
Target: C:\Photos\A
Mode: Recursive Organization ‚úì

Result: Files within A/ are organized into subfolders
```

### Requirement 2: Multi-Level Grouping
**Description:** Support nested pattern detection

**Example:**
```
Input: amb_1_002.jpg, amb_2_005.jpg

Level 1 Detection: "Amb" pattern ‚Üí creates Amb/ folder
Level 2 Detection: "_1_" vs "_2_" ‚Üí creates 001/ and 002/ subfolders

Result:
  Amb/001/amb_1_002.jpg
  Amb/002/amb_2_005.jpg
```

### Requirement 3: User Control
**Description:** Easy enable/disable toggle
**UI Options:**
- Option A: Checkbox "[x] Enable Recursive Organization"
- Option B: Dropdown "Mode: [Recursive] ‚ñº"

### Requirement 4: Safety
**Description:** Prevent infinite loops, data loss, errors
**Mechanisms:**
- Depth limiting (default: 2 levels, max: 5)
- Loop detection (prevent A/A/A/A/... patterns)
- Parent folder lock (no upward moves)
- Pre-flight validation

### Requirement 5: No Extra Steps
**Description:** Should work seamlessly when enabled
**Implementation:** Toggle + organize = works automatically

---

## üèóÔ∏è TECHNICAL ARCHITECTURE

### Component 1: Configuration System

**New Config Section:**
```json
{
  "recursive_organization": {
    "enabled": false,
    "max_depth": 2,
    "skip_folders": ["Sort", "Sorting", "!@#$%"],
    "prevent_upward_moves": true,
    "detect_loops": true
  }
}
```

### Component 2: UI Controls

**Checkbox Implementation:**
```python
recursive_var = tk.BooleanVar(value=False)
ttk.Checkbutton(
    frame,
    text="Enable Recursive Organization (organize within folders)",
    variable=recursive_var
).grid(row=2, column=0)

depth_var = tk.IntVar(value=2)
ttk.Label(frame, text="Max depth:").grid(row=2, column=1)
ttk.Spinbox(frame, from_=1, to=5, textvariable=depth_var, width=5).grid(row=2, column=2)
```

### Component 3: Recursive Collection

**Function Signature:**
```python
def collect_files_recursive(
    source_dirs: List[str],
    logic_func: Callable,
    max_depth: int = 2,
    current_depth: int = 0
) -> Iterator[Tuple[str, str, str]]:
    """
    Recursively collect files for organization with safety checks.

    Args:
        source_dirs: List of directories to organize
        logic_func: Pattern detection function
        max_depth: Maximum recursion depth
        current_depth: Current depth (for tracking)

    Yields:
        (source_path, dest_folder, filename) tuples

    Safety:
        - Stops at max_depth
        - Detects infinite loops
        - Prevents upward moves
        - Skips organized folders
    """
```

### Component 4: Safety Checks

**Loop Detection:**
```python
def detect_pattern_loop(filename: str, current_folder: str, dest_folder: str) -> bool:
    """
    Returns True if organizing would create infinite loop.

    Examples:
        File in A/, pattern detects "A" ‚Üí LOOP (A/A/A/...)
        File in Alpha/, pattern detects "Alpha" ‚Üí LOOP
        File in Photos/, pattern detects "Photos" ‚Üí LOOP
    """
    current_name = os.path.basename(current_folder).lower()
    dest_name = dest_folder.lower()
    return current_name == dest_name
```

**Upward Move Detection:**
```python
def is_upward_move(src_path: str, dest_folder: str) -> bool:
    """
    Returns True if move would go UP the directory tree.

    Example:
        src: C:/Photos/A/Alpha-001.jpg
        dst: C:/Photos/Alpha/  ‚Üê Going UP from A/ to Photos/ level

        This is BLOCKED for safety
    """
    src_dir = os.path.dirname(src_path)
    src_depth = src_dir.count(os.sep)
    dest_depth = dest_folder.count(os.sep)
    return dest_depth < src_depth
```

---

## üîí SAFETY MECHANISMS

### Safety 1: Depth Limiting
**Purpose:** Prevent infinite recursion
**Implementation:** Track current_depth, stop at max_depth
**Default:** 2 levels
**User Control:** Spinbox (1-5 range)

### Safety 2: Loop Detection
**Purpose:** Prevent A/A/A/A/... patterns
**Implementation:** Compare current folder name to destination folder name
**Action:** Skip files that would create loops

### Safety 3: Parent Folder Lock
**Purpose:** Prevent moving files up directory tree
**Implementation:** Calculate depth of source vs destination
**Action:** Block moves where dest_depth < src_depth

### Safety 4: Pre-flight Scan
**Purpose:** See full picture before moving anything
**Implementation:** Collect ALL moves first, validate, THEN execute
**Benefit:** No mid-operation surprises

### Safety 5: Skip List
**Purpose:** Don't organize already-organized folders
**Implementation:** Skip folders in config.recursive_organization.skip_folders
**Default Skip:** ["Sort", "Sorting", "!@#$%", "DUPES", "DUPE SIZE"]

---

## üìä EXAMPLE SCENARIOS

### Scenario 1: Simple Recursive Organization

**Input:**
```
A/
‚îú‚îÄ‚îÄ Alpha-001.jpg
‚îú‚îÄ‚îÄ Alpha-002.jpg
‚îú‚îÄ‚îÄ Beta-001.jpg
‚îî‚îÄ‚îÄ Beta-002.jpg
```

**Settings:**
- Mode: Recursive ‚úì
- Max Depth: 2
- Source: A/
- Target: A/

**Output:**
```
A/
‚îú‚îÄ‚îÄ Alpha/
‚îÇ   ‚îú‚îÄ‚îÄ Alpha-001.jpg
‚îÇ   ‚îî‚îÄ‚îÄ Alpha-002.jpg
‚îî‚îÄ‚îÄ Beta/
    ‚îú‚îÄ‚îÄ Beta-001.jpg
    ‚îî‚îÄ‚îÄ Beta-002.jpg
```

### Scenario 2: Multi-Level Grouping

**Input:**
```
A/
‚îú‚îÄ‚îÄ amb_1_002.jpg
‚îú‚îÄ‚îÄ amb_1_003.jpg
‚îú‚îÄ‚îÄ amb_2_005.jpg
‚îî‚îÄ‚îÄ amb_2_006.jpg
```

**Pattern Detection:**
1. Level 1: "amb" prefix ‚Üí `Amb/` folder
2. Level 2: "_1_" vs "_2_" ‚Üí `001/` and `002/` subfolders

**Output:**
```
A/
‚îî‚îÄ‚îÄ Amb/
    ‚îú‚îÄ‚îÄ 001/
    ‚îÇ   ‚îú‚îÄ‚îÄ amb_1_002.jpg
    ‚îÇ   ‚îî‚îÄ‚îÄ amb_1_003.jpg
    ‚îî‚îÄ‚îÄ 002/
        ‚îú‚îÄ‚îÄ amb_2_005.jpg
        ‚îî‚îÄ‚îÄ amb_2_006.jpg
```

### Scenario 3: Loop Detection (Safety)

**Input:**
```
A/
‚îî‚îÄ‚îÄ A-001.jpg
```

**Pattern Detection:** "A" (would create A/ folder)

**Safety Check:**
- Current folder: "A"
- Destination folder: "A"
- **Loop detected!** ‚Üê BLOCKED

**Action:** Skip this file (log warning)

**Output:**
```
A/
‚îî‚îÄ‚îÄ A-001.jpg  (unchanged - loop prevented)
```

---

## üß™ TEST SCENARIOS

### Test 1: Basic Recursive Organization
```python
def test_basic_recursive():
    """Test organizing within same folder"""
    # Create A/ with files
    # Run recursive organization
    # Verify subfolders created
    # Verify files moved correctly
```

### Test 2: Depth Limiting
```python
def test_depth_limit():
    """Test that recursion stops at max_depth"""
    # Create nested structure (5 levels)
    # Run with max_depth=2
    # Verify only 2 levels organized
    # Verify deeper levels unchanged
```

### Test 3: Loop Detection
```python
def test_loop_detection():
    """Test that A/A/A/... loops are prevented"""
    # Create A/ with A-001.jpg
    # Run recursive (pattern would create A/)
    # Verify loop detected
    # Verify file not moved
```

### Test 4: Multi-Level Grouping
```python
def test_multi_level():
    """Test amb_1_002 ‚Üí Amb/001/ pattern"""
    # Create files with nested patterns
    # Run recursive with max_depth=3
    # Verify nested folder structure
    # Verify correct file placement
```

### Test 5: Upward Move Prevention
```python
def test_no_upward_moves():
    """Test that files can't move up directory tree"""
    # Create A/B/file.jpg
    # Run recursive (pattern detects "A")
    # Verify blocked (would move from B/ to A/)
```

---

## üé® UI MOCKUP

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ File Organizer ‚Äî v6.2 Enhanced Architecture          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Locations                                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Source Directory(ies): C:\Photos\A          [Browse] ‚îÇ
‚îÇ Target Directory:      C:\Photos\A          [Browse] ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ [x] Enable Recursive Organization                    ‚îÇ
‚îÇ     Organize files within source folders             ‚îÇ
‚îÇ     Max depth: [2] levels  (1-5)                     ‚îÇ
‚îÇ                                                      ‚îÇ
‚îÇ     ‚ö† Warning: Source and Target are the same       ‚îÇ
‚îÇ     ‚úì Recursive mode enabled - this is safe         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìã IMPLEMENTATION CHECKLIST

### Phase 1: Configuration & UI
- [ ] Add recursive_organization config section
- [ ] Add UI checkbox/dropdown for enable/disable
- [ ] Add depth spinbox control
- [ ] Add visual indicator when source == target in recursive mode
- [ ] Update help text with recursive mode documentation

### Phase 2: Core Logic
- [ ] Implement collect_files_recursive() function
- [ ] Add depth tracking to file collection
- [ ] Implement loop detection
- [ ] Implement upward move prevention
- [ ] Add skip folder logic

### Phase 3: Safety & Validation
- [ ] Add pre-flight validation for recursive mode
- [ ] Implement pattern stability check
- [ ] Add comprehensive error handling
- [ ] Add operation logging for recursive operations

### Phase 4: Testing
- [ ] Write unit tests (10+ tests)
- [ ] Test loop detection
- [ ] Test depth limiting
- [ ] Test multi-level patterns
- [ ] Test with real-world data

### Phase 5: Documentation
- [ ] Update help text
- [ ] Create user guide for recursive mode
- [ ] Document safety mechanisms
- [ ] Add examples to README

---

## üöÄ ROLLOUT PLAN

### Stage 1: Development
- Implement feature in v6.2
- Write comprehensive tests
- Internal validation

### Stage 2: Testing
- Test with small datasets
- Test edge cases
- Verify safety mechanisms

### Stage 3: Deployment
- Commit to GitHub
- Tag as v6.2
- Update documentation

---

## üéØ SUCCESS CRITERIA

1. ‚úÖ User can organize within same folder (source == target) when recursive mode enabled
2. ‚úÖ Multi-level patterns work correctly (e.g., Amb/001/, Amb/002/)
3. ‚úÖ No infinite loops possible (depth limit + loop detection)
4. ‚úÖ No data loss (parent folder lock prevents upward moves)
5. ‚úÖ Easy to use (single checkbox to enable)
6. ‚úÖ All tests passing (100% coverage for recursive features)

---

## üìä RISK ASSESSMENT

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Infinite recursion | Low | High | Depth limiting + loop detection |
| Data loss | Low | High | Parent folder lock + pre-flight validation |
| Performance issues | Medium | Medium | Limit max_depth to 5, optimize scanning |
| User confusion | Low | Low | Clear UI, good documentation |
| Upward moves | Low | Medium | Explicit check, blocked by default |

**Overall Risk Level:** LOW (with proper safety mechanisms)

---

## üîÑ COMPATIBILITY

**Backward Compatibility:** 100%
- Recursive mode is OFF by default
- Existing workflows unchanged
- Users must explicitly enable feature

**Forward Compatibility:**
- Config saved, persists across sessions
- Depth setting remembered
- Skip folders configurable

---

**End of Feature Specification**
